<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Routing</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
     integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI="
     crossorigin=""/>
     <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
     integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM="
     crossorigin=""></script>

    <script src="a-star.js"></script>
    <script src="dijkstra.js"></script>

    <style>
        #mapid {
            height: 90vh;
        }
    </style>
</head>
<body>

    <div id="mapid"></div>

    <div id="data">
        <div id="nodes">

        </div>
        <div>
            <button id="toggle-nodes">Toggle Nodes</button>
            <button id="astar-btn" style="background-color: blue; color:white;">A* Algorithm</button>
            <button id="dijkstra-btn">Dijkstra's Algorithm</button>
        </div>
    </div>

    <script>
        let selectedAlgorithm = 'astar';

      
let ab = true;
let aid = -1;
let bid = -1;
const mymap = L.map('mapid').setView([49.282416676923065,-123.12200205769232], 15);   
const line = L.polyline([], {color: 'black', weight:10}).addTo(mymap);
const a = L.marker([0, 0]).addTo(mymap);
const b = L.marker([1, 1]).addTo(mymap);

mymap.setMaxBounds([
            [48.1644000, -120.1457000],
            [49.6033000, -123.1898000]
        ]);



L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    attribution: '',
    maxZoom: 17,
    subdomains: "abc"
}).addTo(mymap);

fetch("map.json")
    .then(response => response.json())
    .then(data => {
        localStorage.setItem("data", JSON.stringify(data.nodes));

        let l = 0;
        for (let k in data.nodes) l++;

        document.getElementById('nodes').textContent = `${l} nodes in the map`;
    });

//Select buttons 
const astarButton = document.getElementById('astar-btn');
const dijkstraButton = document.getElementById('dijkstra-btn');

//Attach Event listener
astarButton.addEventListener('click', () => {
    selectedAlgorithm = 'astar';
    showActive(astarButton,dijkstraButton);
    
});

dijkstraButton.addEventListener('click', () => {
    selectedAlgorithm = 'dijkstra';
    showActive(dijkstraButton,astarButton);
});

function showActive (active, inactive) {
    active.style.backgroundColor = "blue";
    active.style.color = "white";

    inactive.style.backgroundColor = "#ffffff";
    inactive.style.color = "black";
}



mymap.on('click', (e) => {
    let nn = nearestNeighbour(e.latlng["lat"], e.latlng["lng"]);

    if (ab) {
        a.setLatLng([nn.lat, nn.lng]);
        aid = nn.id;
        ab = false;
    } else {
        b.setLatLng([nn.lat, nn.lng]);
        bid = nn.id;
        ab = true;
    }

    if (aid > 0 && bid > 0) {
    let result;
    if (selectedAlgorithm === 'astar') {
        result = astar(aid, bid);
    } else {
        result = dijkstra(aid, bid);
    }

    console.log("Result:", result);

    if (result) {
    let path;
    let traversedNodes;
    
    
    if (selectedAlgorithm === 'astar') {
        path = constructPathAstar(result.parent, bid);
        traversedNodes = [];
        while (result.parent) {
            traversedNodes.push(result.id);
            result = result.parent;
        }
    } else {
        path = constructPath(result.previous, bid);
        traversedNodes = Object.keys(result.previous).filter(nodeId => result.previous[nodeId] !== null);
    }

    
    line.setLatLngs(path);
    displayTraversedNodes(traversedNodes, 3000); // Display traversed nodes for 3 seconds
}

}

});

function displayTraversedNodes(traversedNodes, duration) {
    let data = JSON.parse(localStorage.getItem('data'));
    let circles = [];

    for (let nodeId of traversedNodes) {
        if (data[nodeId]) {
            let nodeCircle = L.circle([data[nodeId].lat, data[nodeId].lon], {radius: 2, color: 'yellow'}).addTo(mymap);
            circles.push(nodeCircle);
        }
    }

    setTimeout(() => {
        for (let circle of circles) {
            mymap.removeLayer(circle);
        }
    }, duration);
}




function constructPathAstar(result, goalId) {
    let data = JSON.parse(localStorage.getItem('data'));
    let path = [];
    let currentNode = result;

    while (currentNode) {
        if (data[currentNode.id]) {
            path.unshift([data[currentNode.id].lat, data[currentNode.id].lon]);
        }
        currentNode = currentNode.parent;
    }

    console.log("Constructed path (A*):", path);
    return path;
}
function constructPath(previous, goalId) {
    let data = JSON.parse(localStorage.getItem('data'));
    let path = [];
    let currentNode = goalId;
    // while (node) {
    //     path.push([node.lat, node.lon]);
    //     node = node.parent;
    // }
    while (currentNode) {
        if (data[currentNode]) {
            path.unshift([data[currentNode].lat, data[currentNode].lon]);
        }

        if (previous[currentNode] && previous[currentNode].hasOwnProperty('parent')) {
            currentNode = previous[currentNode].parent ? previous[currentNode].parent.id : null;
        } else {
            currentNode = previous[currentNode];
        }
    }

    console.log("Constructed path:", path);
    return path;
}


//IIFE To display the buttons.
(() => {
        let data = JSON.parse(localStorage.getItem('data'));

        let circles = [];
        for (let key in data) {
            if (data.hasOwnProperty(key)) circles.push(L.circle([data[key].lat, data[key].lon], {radius: 1}));
        }

        // Put all Nodes (circles) into a Layer, so the 13.000 circles do not have to be removed and created on every button click
        let circlesLayer = L.layerGroup(circles);

        document.getElementById('toggle-nodes').addEventListener('click', () => {
            if (mymap.hasLayer(circlesLayer)) {
                mymap.removeLayer(circlesLayer);
            } else {
                mymap.addLayer(circlesLayer);
            }
        });
    })();

    </script>
</body>

</html>